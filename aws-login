#!/bin/bash

SCRIPTNAME=$(basename "$0")

# Colors
lcl="[38;2;85;172;243m" # Blue
gcl="\033[1;32m" # Green
rcl="\033[1;31m" # Red
ncl="\033[0m" # No color

# Gfx side lines and stuff
sls="${lcl}‚îè‚ïæ‚îà" # Side line start
slm="${lcl}‚îÉ " # Side line mid
sle="${lcl}‚îó‚ïæ‚îà${ncl} " # Side line end
spinner=( ‚àô‚àô‚àô ‚óè‚àô‚àô ‚àô‚óè‚àô ‚àô‚àô‚óè )
spc="${gcl}${spinner[0]}" # Spinner characters
rws="\033[${#spinner[0]}D" # Rewind spinner

# More
bul="${lcl}‚ñ¨${ncl} " # Bullet
gcm="${gcl}‚õä$ncl" # Green checkmark

# Deshuffle effect
fake_deshuffle() {
  rnd_list="·µ°·µâ·∂ú·µÖ ∑¬≥·∂¶·µù‚Åæ‚Å∏·∂≥ ≤¬π·µç ≤·µü‚Åø·µ†·µò‚Å∑·∂ø ∏·µà·µè‚Åµ·∂†·µêÀ¢‚Å∂ ≥‚Åª·µ†·∂ß‚Å± ≥‚ÅΩ·µñ‚Å¥‚Åπ·µê·∂ª·µã·∂¢·µç·∂©·∂ú·µÜ¬≤‚Å∞·µíÀ£À°·µû·µõ·µÑ·µá·∂π·µó·µó‚Å∫ ∞·µÉ‚Åø·∂†"
  word="$1"
  word_len="${#word}"
  for ((k=0; k<$word_len; k++)); do
    len_left=$((word_len-k))
    for ((i=0; i<4; i++)); do
      for ((j=0; j<$len_left; j++)); do
        printf "${ncl}${rnd_list:$(( RANDOM % ${#rnd_list} )):1}"
      done
      sleep 0.03
      printf "\033[${len_left}D"
    done
    printf "${word:$k:1}"
  done
}

# Logo
printf "$sls
${slm}\033[35;96;9m‚ñà‚ñÄ‚ñÄ‚ñà ‚ñà   ‚ñà ‚ñà‚ñÄ‚ñÄ    ‚ñà   ‚ñà‚ñÄ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÄ‚ñÄ  ‚óè  ‚ñà‚ñÄ‚ñÄ‚ñÑ\033[0m
${slm}‚ñà‚ñÑ‚ñÑ‚ñà ‚ñà‚ñÑ‚ñà‚ñÑ‚ñà ‚ñÄ‚ñÄ‚ñà ‚ñÄ‚ñÄ ‚ñà   ‚ñà  ‚ñà ‚ñà ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñà  ‚ñà\033[0m
${slm}‚ñÄ  ‚ñÄ  ‚ñÄ ‚ñÄ  ‚ñÄ‚ñÄ‚ñÄ    ‚ñÄ‚ñÄ‚ñÄ ‚ñÄ‚ñÄ‚ñÄ‚ñÄ ‚ñÄ‚ñÄ‚ñÄ‚ñÄ ‚ñÄ‚ñÄ‚ñÄ ‚ñÄ  ‚ñÄ ${bcl}"

fake_deshuffle ·µõ·µâ ≥‚Ñ®.‚©á
printf "\n"

# Help
if [[ "$1" == "--help" ]]; then
  printf "Usage: $SCRIPTNAME [--export-only] [aws_profile]
--help          Show this message.
--export-only   Leave the Environment file ready to source but stay in the current session.
aws_profile     After logging in, assume the specified role for this profile.
"
  exit
fi

start_spinner() {
  #stty -echo # Disable keyboard
  trap "clean_up" INT # Make sure spinner is killed if script is interrupted
  spinner_process &
  spinner_pid=$!
  disown
}

stop_spinner() {
  kill $spinner_pid
  trap - INT
  printf "${rws}" # rewinds cursor position
  printf "$gcm        \n"
  #stty echo # Reenable keyboard
}

# Spinning animation for long tasks
spinner_process() {
  if [[ "$1" == "" ]]; then
    while true; do for i in "${spinner[@]}"; do printf "${rws}$i"; sleep 0.05; done; done
  else
    for i in "${spinner[@]}"; do printf "${rws}$i"; sleep 0.05; done
  fi
}

# Spinner clean up
clean_up() {
  kill $spinner_pid >/dev/null 2>&1
  stty echo
  exit
}

# Files
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
AWS_CONFIG="$HOME/.aws/config"
SHELL_PROFILE="$HOME/.zshrc"
ENVIRONMENT_FILE="$HOME/.aws-login.env"
echo "#AWS-LOGIN ENVIRONMENT" > $ENVIRONMENT_FILE
chmod a+x $ENVIRONMENT_FILE

# Check if we want to start a new session or only export the authentication variables and also if we want to assume a role
if [[ "$1" == "--export-only" ]]; then
  EXP_ENV_ONLY="true"
  AWS_ACCOUNT_PROFILE="$2"
else
  AWS_ACCOUNT_PROFILE="$1"
fi

# Check if needed to login or unlock BW
login_unlock_bw() {
  printf "${slm}${bul}Checking status $spc"
  start_spinner
  bw_status="$(bw status)"
  stop_spinner
  if echo "$bw_status" | grep -q "unauthenticated"; then
    printf "${slm}${bul}Logging in $spc"
    start_spinner
    eval $(bw login $bw_email --passwordenv bw_pwd | grep "export BW_SESSION" | cut -c3-)
    stop_spinner
  elif echo "$bw_status" | grep -q "locked"; then
    printf "${slm}${bul}Unlocking $spc"
    start_spinner
    eval $(bw unlock --passwordenv bw_pwd | grep "export BW_SESSION" | cut -c3-)
    stop_spinner
  fi
}

# Getting credentials
get_creds_from_bw() {
  printf "${slm}${bul}Getting credentials $spc"
  start_spinner
  AWS_2FA_TOKEN=$(bw get totp "$BW_AWS_IAM_NAME") #----------\-> These 2 take a while, so we have a spinner for feedback.
  KEYCHAIN_PWD=$(bw get password "$BW_AWS_KEYCHAIN_NAME") #--/
  stop_spinner
}

# This adds an export environment variable to the sourceable file and/or shell profile
export_to_env() {
  echo "export $1" >> $ENVIRONMENT_FILE
  if [[ "$2" == "--also-shell-profile" ]]; then
    echo "export $1" >> $SHELL_PROFILE
  fi
}

# This will start a new zsh shell with all the variables set or stay in the same session (when used within a script)
start_new_session_or_stay() {
  if [[ "$EXP_ENV_ONLY" == "true" ]]; then
    printf "\r${slm}${bul}AWS session credentials ready $spc$gcl"
    spinner_process 1
    printf "${rws}$gcm    "
    printf "\n\r${sle}\n"
    exit
  else
    printf "\r${slm}${bul}New AWS session started $spc$gcl"
    spinner_process 1
    printf "${rws}$gcm    "
    printf "\n\r${sle}\n"
    bash -c ". $ENVIRONMENT_FILE; exec zsh -i" #this is to start a new session in terminal
    rm $ENVIRONMENT_FILE &> /dev/null
    exit
  fi
}

# Get role arn from .aws/config
get_role_arn() {
  echo $(awk -v profile="profile $AWS_ACCOUNT_PROFILE" '
  BEGIN {found = 0}
  /^\[/{found = 0}
  $0 ~ profile {found = 1}
  found && /role_arn/ {print $3; exit}
' "$AWS_CONFIG")
}

# Setup aws-cli if first run
if ! grep -Fq "export PERSONAL_IAM_PROFILE" $SHELL_PROFILE; then
  printf "${slm}${bul}Let's setup aws-login...\n"
  printf "${slm}${bul}Enter your personal AWS iam profile (find it in '~/.aws/config'): "
  read my_profile
  declare -x PERSONAL_IAM_PROFILE=$my_profile
  printf "\n#AWS-LOGIN\n" >> $SHELL_PROFILE

  export_to_env "PATH=\"$SCRIPT_DIR:$PATH\"" --also-shell-profile
  export_to_env "PERSONAL_IAM_PROFILE=\"$my_profile\"" --also-shell-profile

  echo 'if [ ! -z "$AWS_VAULT" ]; then\
  ZSH_THEME_GIT_PROMPT_PREFIX="%{$fg[yellow]%}("
  ZSH_THEME_GIT_PROMPT_CLEAN="%{$fg[green]%}‚úì%{$reset_color%}"
  ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[red]%}‚úó%{$reset_color%}"
  ZSH_THEME_GIT_PROMPT_SUFFIX="%{$fg[yellow]%})%{$reset_color%}"
  PROMPT='"'"'%{$fg[$NCOLOR]%}${PERSONAL_IAM_PROFILE}%{$reset_color%}@%{$fg[cyan]%}${AWS_ACCOUNT_PROMPT}\
%{$reset_color%}:%{$fg[magenta]%}%c\
$(git_prompt_info) \
%{$fg[red]%}%(!.#.¬ª)%{$reset_color%} '"'"'
fi

# EC2 id translator - this will look for the settings file for the specified server, i.e. my.server.com and then return the ec2 id, i.e. i-1234567890
# You should write this method according to your server provisioning structure
ec2-translate() {
  host_file=$(find "$HOME/my-project/server-provisioning/" -type f -exec grep -l -w " $1" {} +)
  echo $(cat $host_file | grep "ansible_host:" | awk -F": " '"'"'{print $2}'"'"') 
}
# EC2 connect
ec2-connect() {
  ssh -o ProxyCommand="sh -c '"'"'aws ssm start-session --target %h --document-name AWS-StartSSHSession --parameters portNumber=%p'"'"'" deployer@$(ec2-translate "$1")
}' >> $SHELL_PROFILE
fi

if declare -F "ec2-connect" > /dev/null; then
  printf "${slm}${bul}\033[1;33mAuxiliary methods (ec2-connect) are not loaded, you need to start a new session\n\033[0m"
  printf "\r${sle}\n"
  exit
fi

# Setup bitwarden
if command -v bw &> /dev/null && ! grep -q "export BW_CONFIG_USE" $SHELL_PROFILE; then
  printf "${slm}${bul}Bitwarden cli was found, do you want to set it up to login to aws with aws-login? (y/n): "
  read -n 1 use_bitwarden
  
  if [ $(echo $use_bitwarden | tr "[:upper:]" "[:lower:]") == "y" ]; then
    printf "\n${slm}${bul}Enter the exact name (case sensitive) of your Keychain password entry in Bitwarden: "
    read bw_aws_keychain_name

    printf "${slm}${bul}Enter the exact name (case sensitive) of your AWS IAM entry in Bitwarden: "
    read bw_aws_iam_name

    printf "${slm}${bul}You can store your Bitwarden credentials now (encrypted), otherwise you'll have to enter them everytime.\n"
    printf "${slm}${bul}Do you want to store the credentials? (y/n): "
    read -n 1 store_bw_pass

    if [ $(echo $store_bw_pass | tr "[:upper:]" "[:lower:]") == "y" ]; then
      printf "\n${slm}${bul}Enter your Bitwarden email: "
      read bw_email

      printf "${slm}${bul}Enter your Bitwarden password: "
      read -s bw_pwd
    fi

    printf "\n"

    # Save BW credentials to shell profile and current session
    printf "\n#Bitwarden\n" >> $SHELL_PROFILE
    export_to_env "BW_MPW=\"$(echo $bw_pwd | base64 )\"" --also-shell-profile
    export_to_env "BW_EM=\"$(echo $bw_email | base64 )\"" --also-shell-profile
    export_to_env "BW_AWS_KEYCHAIN_NAME=\"$bw_aws_keychain_name\"" --also-shell-profile
    export_to_env "BW_AWS_IAM_NAME=\"$bw_aws_iam_name\"" --also-shell-profile
    export_to_env "BW_CONFIG_USE=yes" --also-shell-profile
  else
    printf "\n"
    export_to_env "BW_CONFIG_USE=no" --also-shell-profile
  fi
  source $ENVIRONMENT_FILE
fi

# If bitwarden is setup, use it.
if command -v bw &> /dev/null && grep -q "export BW_CONFIG_USE=yes" $SHELL_PROFILE; then
  printf "${slm}${bul}Bitwarden enabled $gcm\n"
  bw_pwd="$(echo $BW_MPW | base64 --decode)"
  declare -x bw_pwd
  bw_email="$(echo $BW_EM | base64 --decode)"
  declare -x bw_email

  login_unlock_bw
  get_creds_from_bw

  # Put keychain password in clipboard
  printf "$KEYCHAIN_PWD" | pbcopy
  # Print info message
  printf "${slm}${bul}Your keychain password is now on the clipboard \033[1;32m·µñ·µÉÀ¢·µó·µâ\033[0m\n"
  printf "${slm}${bul}And here's a 2fa token for AWS vault: \033[1;32m$AWS_2FA_TOKEN\033[0m\n"
fi

# Login to aws with personal iam and export the needed credentials (env vars)
printf "${slm}${bul}"
aws-vault exec $PERSONAL_IAM_PROFILE -- env | grep "^AWS_" | while read line ; do export_to_env "$line"; done 
if ! grep -q "AWS_VAULT" "$ENVIRONMENT_FILE"; then
  printf "\r${slm}${bul}Login failed \033[1;31m‚úó\033[0m                                 \n"
  printf "\r${sle}\n"
fi

if [[ "$AWS_ACCOUNT_PROFILE" == "" ]]; then
  declare -x AWS_ACCOUNT_PROMPT="root-iam"
  start_new_session_or_stay
else
  source $ENVIRONMENT_FILE

  # Assume the admin role on the server's account and store the credentials to variable
  ASSUMED_CREDS=$(aws sts assume-role --role-arn "$(get_role_arn)" --role-session-name "deployer")

  export_to_env "AWS_ACCESS_KEY_ID=\"$(echo "$ASSUMED_CREDS" | jq '.Credentials.AccessKeyId')\""
  export_to_env "AWS_SESSION_TOKEN=\"$(echo "$ASSUMED_CREDS" | jq '.Credentials.SessionToken')\""
  export_to_env "AWS_SECURITY_TOKEN=\"$(echo "$ASSUMED_CREDS" | jq '.Credentials.SessionToken')\""
  export_to_env "AWS_SECRET_ACCESS_KEY=\"$(echo "$ASSUMED_CREDS" | jq '.Credentials.SecretAccessKey')\""
  export_to_env "AWS_SESSION_EXPIRATION=\"$(echo "$ASSUMED_CREDS" | jq '.Credentials.Expiration')\""

  declare -x AWS_ACCOUNT_PROMPT="$AWS_ACCOUNT_PROFILE"
  start_new_session_or_stay
fi
